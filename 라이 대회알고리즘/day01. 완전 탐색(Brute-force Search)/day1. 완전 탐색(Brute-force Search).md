# day1. 완전 탐색(Brute-force Search)

가능한 경우를 일일이 다 탐색

* 탐색의 범위가 아주 작거나
* 게임을 구현하거나
* 몇가지 중에서 몇가지를 고르는
* 탐색의 범위가 작아서 캐시를 사용 가능한








## 2309번: 일곱 난쟁이
> 9명의 난쟁이 중에서 7명의 난쟁이를 찾는 문제

그냥 생각해보면 7번의 for-loop를 돌리면 된다.
부분합, 전체합의 개념을 생각하면서...조금만더 수학적으로 생각해보면

"9명 중에서 7명을 찾는 문제" -> "9명 중에서 2명을 찾는 문제"로 변한다

2명을 찾는 문제로 바꾸면 2번의 for-loop로 해결 가능

* step1
	- 9명 중에서 7명을 찾는 문제
* step2
	- 9명 중에서 2명을 찾는 문제


## 2231: 분해합
> 자연수 N의 생성자를 찾는 문제

1~1000000 까지의 모든 숫자들을 계산해보면 된다
하지만 최적화를 해본다면 생성자라는 것은 N 보다 클수가 없다
N보다 큰 숫자를 탐색할 필요는 없다

탐색의 시작범위도 N이 10000인데 1부터 탐색할 필요는 없다
각 자릿수의 숫자는 0~9의 범위를 가지고 있다
자릿수 * 9 보다 작은 숫자들은 탐색할 필요가 없다

* step1
	- 1,000,000 까지의 숫자 중에서 생성자를 찾는 문제
* step2
	- 1~N 까지의 숫자 중에서 생성자를 찾는 문제
* step3
	- (N- 9*(자리 개수)) ~ N 까지의 숫자 중에서 생성자를 찾는 문제
* step4
	- 자리 개수, 분해합을 구하는 로직을 개선 (이건 각 언어마다 조금씩 다를듯)

> 자릿수 len(str(number))
> 각 자리들의 합 list(map(int, str(number)))

## 3085: 사탕 게임
> 인접한 위치의 사탕 두개를 교환했을때, 가장 길게 연속되는 같은 사탕의 개수를 찾는 문제

조건을 꽤 잘봐야하고, 구현에 신경을 써야 하는 문제

* step1
	- 보드의 크기가 3~50 이므로, 완전 탐색을 했을때 최대 어느정도의 for-loop가 수행될지 계산한다
* step2
	- 연속되는 사탕의 숫자를 계산할때 매 x,y 마다 왼쪽, 아래쪽으로 계산해보는게 아니라, 한 row, col을 쭉돌면서 한번에 계산한다


## 10448: 유레카 이론
> 정확히 세개의 삼각수로 이루어진 수인지를 탐색하는 문제

N을 만드는 세개의 숫자 a,b,c를 고르는 문제이다

N = a + b + c 이기 때문에 a,b를 특정하면 c를 O(1)에 알아낼 수 있다

근데 이 문제처럼 N이 굉장히 작은 문제에서는 캐시를 사용할 수 있고, 몇번의 쿼리가 들어오는 부분도 캐시를 사용할 수 있다

* step1
	- 3중 for-loop로 a,b,c를 탐색
* step2
	- 2중 for-loop로 a,b를 탐색. c는 a,b에서 계산해냄
* step3
	- 1~1000까지의 삼각수를 미리 계산. 1부터 정직하게 for-loop 도는게 아니라 삼각수를 기준으로 for-loop
* step4
	- N이 굉장히 작은 문제이다. 삼각수 1개들을 캐싱할 수 있었다면, 삼각수 2개로 이뤄진 숫자의 존재유무도 캐싱할 수 있다
	- 같은 논리로 삼각수 3개로 이뤄진 숫자들도 미리 계산할 수 있다
	- 각 쿼리에서 미리 계산된 삼각수 3개의 조합에 포함되는지만 확인하면 된다

## 2503: 숫자 야구
> 숫자 야구 게임 구현

체스판의 크기는 8 * 8
아주 작기 때문에 체스판을 미리 만들어두고 비교에 사용하면 간편하다

* step1
	- 각 게임마다 candi을 초기화하고, 각 쿼리마다 candi를 지워간다

> 나누기 후 정수 변환 integer // 100


## 1018번: 체스판 다시 칠하기
> 체스판을 자를 위치를 고르고, 거기서부터 다시 칠한다면 몇개나 다시 칠해야 하는지 탐색하는 문제

원소가 n개인 집합의 부분집합 갯수는 2^n이다.
각 원소는 포함되거나 포함되지 않거나 2가지 선택권을 가지고 원소는 총 n개이니 2가 n번 곱해서 2^n이 된다.
문제에서의 표현은 수열과 부분 수열이지만 부분집합을 고르는 것과 동일한 상황이니 공집합은 빼고 2^n-1개의 모든 부분 집합에 대해 합이 s와 일치하는지 확인하면 된다.

* 사실상 "부분집합"을 고르는 문제. 2^n. 이고 크기가 상당히 작다는 것을 알아야 한다
* 반드시 "1개"는 골라야 하기 때문에 공집합을 제외해야 한다

* step1
	- 부분집합을 고르는 문제. 고르느냐, 안고르느냐를 재귀호출로 구현할 수 있다








































