# day12. 비트마스킹(Bit Masking)



유형이 굉장히 다양함
그리고 비트마스킹해야하는 범위는 굉장히 작음. 아무리 커도 14 이하 느낌?

무언가를 선택하고 안하고, 줍고 안줍고를 비트마스킹으로 나타낼 수 있다
심지어 3가지 선택지, 9가지 선택지 같은 것들도 여러개의 비트를 하나로 해서 표현할 수 있다

> 그리고 used 비트를 사용할때는 지금 추가하려는 비트가 이미 추가되어있는지를 반드시 고려해야한다

* DFS 비트마스킹
* 현재 위치가 필요없는 DFS 비트마스킹
* 3중 DP
* 3가지 이상의 선택지(3-4비트를 묶어서) 비트마스킹 (encode, decode 구현)
* BFS 비트마스킹




## 11723번: 집합

비트연산자를 익히는 문제


## 2098번: 외판원 순회

DFS + 비트마스킹 visit 배열 + DP

비트마스킹 visit 배열만 써서는 해결할 수 없다, DP도 같이 사용해야한다

`def TSP(N, board, visit, cache, idx):`

## 1102번: 발전소

이미 켜져있는 발전소가 있을 때, 최소의 비용으로 정해진 개수의 발전소를 돌리는 것입니다.

그런데 조금 자세히 들여다보면 생각보다 구현이 간단하지 않습니다.

최종적으로 똑같은 발전소를 켠다고 하더라도 발전소를 켜는 순서에 따라 비용이 달라질 수 있기 때문이죠.


`def step1_dfs(N, board, P, DP, visit, used, count, idx):`

처음에는 위처럼 현재 위치 idx를 기준으로 DFS 탐색을 진행했다

근데 반례가 있었다.

하나의 발전소에서 하나의 다른 발전소만 켤수 있는게 아니라, 비용이 낮다면 하나의 발전소에서 나머지 모두를 켜는게 답이 될수도 있다.

때문에 현재 위치에서 여러개를 켜야할수도 있다.


`def step2_dfs(board, N, P, DP, used, count):`

현재 위치에서 여러개를 켜야할때, 현재 위치에서 여러 방향으로 탐색하기보다는

아예 현재 위치라는 것을 기준에서 제외해야한다

'현재 켜진 발전소' 에서 '현재 켜지지 않은 발전소'를 켜는 방향으로 탐색을 해보자

DP[used] = 현재 켜진 발전소에서 나머지 것들을 켜서 P가 되게끔 할때의 최소 비용

매번 for i -> for j 이중루프문으로 켤 수 있는 발전소를 켜면서 탐색을 진행한다


이때 P가 0이 될 수도 있고, 최초에 켜진 발전소가 없을 수도 있고, 이미 P 보다 큰 테스트 케이스도 들어온다는 것에 주의


## 1562번: 계단 수

`DP[count][last][used]`

count, last, used 3중 DP를 사용


## 2133번: 타일 채우기

타일 문제. 대표적인 DP

세로길이가 3이라서 좀 어렵다

일반적인 타일 문제로 접근하는 법 vs 비트마스킹으로 해결하는 방법. 으로 나뉘는 것 같다

기존에 내가 풀었던 방식은 타일 문제로 접근하는 것인데,

타일 문제로 접근시에.. 가능한 타일 모양을 모두 미리 계산해본뒤 n-x 번째 타일부터 해당 타일을 붙인다는 생각으로 점화식을 세운다

근데 세로길이가 3이라서 딱 떨어지는 모양만 가능한게 아니라, 계~속 걸치게 모양을 만들수 있다

그래서 이전 DP 들을 모두 더해야 하는 문제이다

1) n에 대해서 n-2 까지의 dp 값에 가로길이 2 짜리 타일로 만들수 있는 3가지 경우를 곱한 경우
-> dp[n-2] * 3

2) n에 대해서 0 ~ n-4 까지의 타일 뒤에 자신을 붙혀서 만들 수 있는 2가지 경우를 곱한 경우
-> ( dp[0] + dp[2] + ... dp[n-4] ) * 2


비트마스킹으로 해결하는 방법

맨 윗칸만 이미 채워져 있다면 100(2)
2칸만 채워져 있다면 011(2)
전체가 안채워져 있다면 000(2)

이런식으로 세로칸을 쪼개서 DP를 세울 수도 있다.

타일의 모양이 복잡하다면 이런식으로 접근하는게 좋을듯


맨 윗 칸만 이미 채워져 있다면 100(2), 아래의 2칸만 채워져 있다면 011(2), 전체가 안 채워져 있다면 000(2) 이런 방식으로 표현할 수 있습니다.

## 1194번: 달이 차오른다, 가자

열쇠가 6개

열쇠는 여러개 있을 수 있고, 여러번 사용할 수 있다

방문한 x,y 좌표를 다시 방문하지 않기 위한 visit
획득한 열쇠를 나타내는 used
(근데 특정한 x,y 좌표를 방문했다면 이동 경로랑 상관없이 반드시 특정 열쇠를 획득하게끔 되어있지 않나..?
하지만 문제를 쉽게 풀려면 획득한 열쇠를 알고있는게 좋을듯)

BFS


## 2001번: 보석 줍기

visit(섬)(보석수)

근데 보석수가 최대 14개임

O(N * 2^K)



처음에는 DFS로 해결하려고 했다. 근데 갔던곳을 또갈수도 있고, 보석을 마지막에 줍는게 좋을수도 있고 경우가 다양하다

게다가 1로 돌아왔다고 여행이 끝난게 아니라 1에서 다시 다른 곳으로 보석을 줍고 1로 돌아올 수도 있다


DFS로는 답이 안나와서 해설을 보니 BFS라고 한다
그래프 탐색은 DFS로 해결하는게 일반적이라고 생각했는데, 달이차오른다 문제처럼 BFS였다고 하니..실제로 이런식으로 접근할 수 있을지 잘 모르겠다


결국 visit, used를 잘 써야하는게 탐색, 비트마스킹 문제이다

used는 K(14)개의 보석을 줍냐 안줍냐이고...visit을 어떻게 선언해야할까?

처음에는 visit(1<<14)(count)(N) 으로 선언했는데 이러면 메모리초과다

생각해보면 queue에 들어가는 것과 visit 배열이 "꼭" 같은 필요는 없다

count는 queue에 넣어도 되지만 visit에는 꼭 넣지 않아도 된다. used에서 계산가능하기도 하고..


그리고 예제를 따라 그려보면, 1번섬에는 무조건 와야하기 때문에 1번섬에 보석이 있다면 가장 마지막에 줍는게 좋다


그리고 비트마스킹 해야 하는 대상이 diamond가 있는 섬 index가 아니라 diamond 배열에서의 해당 섬의 index 라는 점을 명심하자.
섬 자체는 100번까지 가능하다

그리고 방문한적이 없는 노드라면 보석을 줍고 진행하게 될텐데...이때 visit 배열상에서는 방문한적이 없어도, 보석 자체는 이미 주웠을수도 있다

이러면 보석이 중복 카운팅된다

> visit 배열에서 방문한적이 없더라도, 이미 보석을 주워서 used에 가지고 있다면 보석을 줍지 않고 탐색을 진행해야 한다

마찬가지로 이미 used에 들어가있는걸 or 연산으로 넣어도 변화는 없다.
하지만 used에서 보석을 제거할때는 추가되지않은 보석이 빠지는것이기 때문에 오류가 생긴다.

> used에 추가할때는 이미 used에 들어가있는지를 반드시 고려해야한다


좀 더 빠른 풀이들을 보니, 우선순위큐나 disjoint set을 사용해서 엄청 빠르게 풀기도 하는 것 같다


## 1525번: 퍼즐

9가지 숫자가 가능한 9칸. 그래서 81 비트가 필요한가? 라고 생각했다

근데 그렇게 접근하지말고, 4비트를 묶어서 생각해보면 9가지 숫자 0-8을 3비트로 표현할 수 있다
0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111

이때 0과 움직일 칸을 비트 연산을 통해 교환해줘야하는데 이 과정을 잘 구현해야 한다

```python
    # 이동할 위치의 비트를 떼어낸다
    temp_board = current_board & (15 << ((8-next_index) * 4))
    # 이동할 위치에 0을 옮긴다
    next_board = current_board - temp_board
    temp_board >>= 4
    # 0이 옮겨진 장소의 숫자를 0의 위치로 옮긴다
    next_board += temp_board
```































































