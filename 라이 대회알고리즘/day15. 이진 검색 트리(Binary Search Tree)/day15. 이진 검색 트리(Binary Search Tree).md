# day15. 이진 검색 트리(Binary Search Tree)
> https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220789373847&navType=by



① 왼쪽 자식이 있다면, 왼쪽 자식의 key 값보다 자신의 key 값이 커야 한다.
② 오른쪽 자식이 있다면, 오른쪽 자식의 key 값보다 자신의 key 값이 작아야 한다.

트리의 높이가 N이고 노드 개수가 2^N-1일 때 저렇게 모든 리프 노드의 깊이가 같은 형태를 포화 이진 트리(perfect binary tree)라고 하고, 포화까지는 아니더라도 모든 리프 노드의 깊이가 N 또는 N-1이고 깊이 N인 단계의 리프 노드들은 왼쪽으로 쏠려 있는 형태를 완전 이진 트리(complete binary tree)라 합니다.


balanced binary search tree 는 노드 깊이가 logN
한쪽으로 쏠린 이진 트리는 노드 깊이가 N

그래서 항상 최적의 시간 복잡도 logN에 근접하도록 값들의 위치를 계속해서 균형있게 유지해주는 blanced tree 들이 있다
AVL 트리, 레드 블랙 트리, splay 트리

균형 트리의 규칙
어떤 정점에 대해서도 양쪽 서브트리의 높이 차가 1을 넘지 않는다


탐색, 삽입, 삭제 시간 복잡도 logN (균형잡혀있을때)


K Insertion
① 현재 정점의 key보다 K가 작으면 왼쪽 서브트리에 삽입해야 한다. 왼쪽 서브트리에서 연산을 계속한다. 만약 현재 정점의 왼쪽 자식이 없다면, key가 K인 새 노드를 만들어 현재 정점의 왼쪽 자식으로 만들고 연산을 종료한다.
② 현재 정점의 key보다 K가 크면 오른쪽 서브트리에 대해 위와 같은 연산을 한다.

K Deletion
삭제는 좀 어렵다. 실제로 구현해보면서 익혀보는게 좋을듯



BST를 파이썬에서 실제로 구현해보는 것은 화이트보드 코테에서 많은 도움이 될듯
> 탐색, 삽입, 삭제 연산을 어떻게 구현할 것인가? 제대로 이해하고 있는가?

```python
# class 만드는거 참고
class Tree:
    def __init__(self, element):
        self.element = element
        self.parent = self
        self.num = 1
```


BST를 사용하는 문제보다는...이런 유형의 문제들이 추천문제로 있다

* set DP, map DP
* set, map




## 1269번: 대칭 차집합

set과 교집합 연산을 사용하면 된다


## 1620번: 나는야 포켓몬 마스터 이다솜

이름 map, 인덱스 map 2개로 해결 가능
혹은 이름과 인덱스가 겹치지 않기 때문에 아예 map 하나로도 해결 가능


## 1351번: 무한 수열

DP라는 느낌이 딱오는데 N이 10^12
하지만 전체가 필요한건 아니다

메모이제이션을 배열이 아니라 Map으로 구현하면 해결 가능



## 2287번: 모노디지털 표현

어떻게 풀어야할지 감이 잘 안오는 문제

DFS로 생각해도 분기를 어떻게 해야할지? 단순히 사칙연산만 있어보이진 않는데..
가장 최소 K-길이 이니깐 BFS ??

일단 탐색 방향 자체가 모호하다
적용해야할 연산의 종류가 5개다.라는 것 까지는 어느정도 생각이 닿았다
근데 괄호까지 적용하려니 막혔다.

* 문제를 반대로 생각하는 것
* 한번의 K에 쿼리가 여러번 들어온다는 점
* 8을 넘어가는 K-길이는 없다는 점

K-길이의 N을 이루는 수식을 찾는 문제가 아니라 K-길이가 가능한 모든 수를 미리 구해둔다
K-길이는 최대 8
여러번의 쿼리가 들어올때 K-길이를 이루는 수 중에서 해당 값이 있는지 없는지만 확인한다

그렇다면 탐색 자체를 어떻게 할 수 있을까?

* 덧셈
* 뺄셈
* 곱하기
* 나눗셈
* 그리고 K 숫자를 덧붙이기 (10배하고 K더하기)

이렇게 다섯가지 연산이 가능하다

각 K-길이에서 가능한 모든 수를 구할 것이다.
그러면 K-길이에서 가능한 모든 수를 구하려면 K 보다 작은 길이의 수를 모두 이용해서 위 5가지 연산을 적용해볼 수 있을 것이다.

이때 K 숫자 덧붙이기 연산이 애매한데...
K, KK, KKK ... KKKKKKKK 인 수를 미리 cache에 넣어두고, 이후에는 사칙연산만 수행하는 식으로 전처리를 할 수 있다

이때 사칙연산에서 0이나 음수가 나오면 안된다는 예외를 잘 처리해야한다




























