# 번외1. LIS(Longest Increasing Sequence)




* 순열의 합
* 증가하는 순열 길이
	- DP + 2중 for-loop
	- DP + 바이너리서치
	- segment-tree
* 순열 자체를 출력
	- 역추적



증가수열
감소수열
바이토닉수열
바이토닉정렬





## 11053번: 가장 긴 증가하는 부분 수열

* step1
	- DP + 2중 for-loop
	- i를 선택했을때, 0 ~ i-1 사이의 j가 arr[j] < arr[i] 를 만족한다면, DP[i] = max(DP[i], DP[j] + 1) 을 확인한다
* step2
	- segment-tree
	- kotlin으로 segment-tree를 제출하면 step1 보다도 느리다
* step3
	- DP + 바이너리서치



## 12015번: 가장 긴 증가하는 부분 수열 2

* step1
	- DP + 바이너리서치

바이너리서치로 해결하는 방법은,
현재 넣어야하는 값이 list의 마지막값보다 크다면 그냥 넣는다.
작다면 list의 구성요소 중 lower bound 값과 교체를 한다.
왜냐하면 list의 구성요소 중 무언가는 arr[i] 보다 작다는 것인데 (최소한 마지막 값은)
이때 더 작은 값으로 list를 구성하는게 가장 긴 증가 부분 수열을 이루는데 더 유리하다는 것이다. (여기서는 '길이'만 중요하므로!!)

그래서 list의 구성요소 중 더 작은 값을 for-loop N번에 찾는게 아니라, 이분 탐색으로 logN번만에 찾는게 포인트

10 20 30 40 50
증가수열이 만들어진 상태에서 35를 넣어야 한다면
40과 35를 교체해야 한다

35보다 큰 첫번째 값 (lower Bound)

이분탐색을 구현할때 index 의 값이 -가 되지 않도록 주의. lb = mid + 1, rb = mid - 1로 하는 경우 rb는 마이너스 값이 될 수 있으므로 주의. lb를 리턴해서 AC



## 12738번: 가장 긴 증가하는 부분 수열 3

음수가 존재하는 최대 증가 부분 수열 구하기.


## 14002번: 가장 긴 증가하는 부분 수열 4

역추적 방법

최장 순열 길이가 -1 씩 차이나는 원소들을 고른다

10 20 10 30 20 50
이라고 하면
1 2 1 3 2 4
일텐데

4 -> 3 -> 2 -> 1 순의 원소들을 골라서 역순으로 출력하면 된다

```java
    for (i in N -1 downTo 0) {
        if (DP[i] == answer) {
            st.addFirst(numbers[i])
            answer -= 1
        }
    }
    st.forEach { print("$it ") }
```



## 14003번: 가장 긴 증가하는 부분 수열 5

DP + 바이너리서치
로 해결 가능한데, 문제는 바이너리 서치 사용시에 LIS 배열은 DP와 다르게 최장 길이가 아니라, element들을 가지고 있다.
이 element들의 순서가 답은 아니다.

따라서 LIS 배열 외에 DP 또한 바이너리 서치시에 만들어줘야 한다.

증가 수열에 그냥 추가하게 되는 경우에는 DP 배열 또한 최장 길이를 넣어주면 되는데,
이분탐색으로 어떠한 LIS 상의 index를 찾게 되는 경우

생각을 해보자.
구해진 index 위치의 LIS 원소가 나타내는 것은 'element' 그 자체이다.
하지만 index 자체가 의미하는 것은 원소의 위치 뿐만 아니라 최장 길이 그 자체이다.
따라서 DP[i] 는 그 index를 가지면 된다. 그게 i번째 수가 가질 수 있는 최장 길이 그 자체이다.



## 11054번: 가장 긴 바이토닉 부분 수열

처음에는 DP(N)(curved) 2차원 배열로 해결하려했는데, 왜인지는 모르겠는데 이 방법으로는 반례가 있다.
https://www.acmicpc.net/board/view/32529

이 문제는 최장길이증가수열, 최장길이수감소열 두가지를 계산해서
특정 index 에서 각 수열의 최장길이를 더한 값이 가장 커지는 지점이 답이 된다.
































