# day10. 너비 우선 탐색(Breadth-First Search)

BFS 역시 컴포넌트의 개수를 세거나 각 컴포넌트의 크기를 구하는 데는 사용 가능합니다.
DFS가 깊이를 중시했던 것에 반해 BFS는 넓이를 중시한다는데요.

k단계에 방문하는 정점들은 시작점으로부터 최단거리가 k입니다.

DFS에 스택이 필요했던 것과 대조적으로, BFS는 큐가 필요합니다.

BFS 또한 DFS와 마찬가지로, 인접 리스트를 사용하였을 때 시간복잡도가 O(V+E)입니다.



굉장히 다양한 문제 유형이 있다

1. 최단 거리
  * 단순히 queue를 통해 확장해나가면됨
2. 깊이를 알고싶을때
  * 현재 큐의 크기만큼 for-loop를 도는 반복문이 내부에 하나더 추가로 필요
3. 3차원 BFS
4. 2개의 출발점(불 vs 상근이, 홍수물 vs 쥐)
5. 한번 정도 벽을 부수고 이동하는게 가능한 탐색
6. 한번에 이동할 수 있는 거리가 변함
7. 보드판의 형상 자체를 기억(set visit)해야하는 문제
8. 매 step마다 visit을 초기화해야하는 문제




## 6593번: 상범 빌딩

3차원 미로


## 5427번: 불

불, 상근이. 2개의 큐를 이용한 BFS


## 2206번: 벽 부수고 이동하기

2차원 공간이지만 벽을 부술수있다. 그래서 벽을 부쉈다. 안부쉈다 2층짜리 건물로 생각해볼 수 있다. 3차원으로

상하좌우 + 벽을 부수면서 상하좌우. 8가지 방향으로 이동이 가능하다고 생각해야한다

## 7562번: 나이트의 이동

단순 상하좌우가 아니라 나이트의 8방향으로 이동


## 5014번: 스타트링크

한번의 이동거리가 입력으로 주어짐


이동하는 방향이 2개이고...1차원이니깐 DP로도 풀 수 있지 않을까?
생각했는데 DF로는 못푼다
+, - 양방향으로 이동이 가능해서 dfs로 탐색할때 탐색이 안끝난다 (왼쪽,오른쪽,왼쪽 무한 반복 가능)
(visit 배열이 없는 문제가 생긴다)


## 1697번: 숨바꼭질

BFS도 가능하지만, 이동하는 방향이 +만 가능하고 2가지 경우만 가능해서 DP로도 해결 가능

* step1
  - BFS
* step2
  - DP


## 1525번: 퍼즐

빈칸의 이동은 4방향으로 가능하다.

9개의 칸에 대해서, 이런 모양을 탐색한 적이 있는지 visit 배열을 쓰려면
visit[9][9][9][9][9][9][9][9][9]
9^9 = 3.8억?

배열에 무식하게 때려넣는 방법은 안된다

이럴때는 문자판의 형상을 String으로 변환해서 관리하던가 해야한다

visit 배열을 String + Set 을 쓴다면 가능

빈칸의 이동을 구현하기 위해서 처음 생각했던 것은

encode, decode 하는 함수를 만들어서 매번 pop -> decode -> move -> encode -> push 하는 방법이였다.


이 방법도 충분히 동작하지만 상하좌우 이동을 자세히보면
1차원 직선 모양에서 좌우는 -1,+1 상하는 -3,+3 으로 이동한다는 것을 알 수 있다
이것을 잘 구현해서 좀 더 빠르게 해결 가능한다

* step1
  - BFS + set visit + encode/decode
* step2
  - BFS + set visit + string replace


## 1039번: 교환

정확히 K 번째까지 step을 진행한 후 그 때의 수 중 가장 큰 수를 출력하는 문제

123 -> 132 -> 123 같은 이동이 가능하다
즉 매 step마다의 visit 배열이 다르다는것.

이말은 매 step마다 visit 배열을 초기화해서도 할 수 있고,
K가 10 정도로 매우 낮으니 visit 배열에 차원을 추가할 수도 있다
아니면 매 step마다 새로운 visit 배열을 사용할 수도 있다

* step1
  - BFS + init visit each step


































