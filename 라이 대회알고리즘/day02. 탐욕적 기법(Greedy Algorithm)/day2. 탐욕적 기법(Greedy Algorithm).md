# day2. 탐욕적 기법(Greedy Algorithm)
> https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220775134486&navType=by


한 번의 선택을 한 이후에도 원래 문제와 동일한 성질들이 성립하고 있습니다.
성질이 동일하게 보존되므로 아까 했던 전략을 계속 취해도 정답을 얻을 수 있는 것이죠.


왜냐면 문제를 딱 보고 그리디인지 알기가 쉽지 않기 때문입니다.
대체로 그리디 문제들은 뭔가 문제를 읽다 보면 "왠지 이러면 될 것 같은데?" 하는 감이 옵니다. 


Q. 동전을 가장 적게 써서 어떤 금액을 표현하는 방법
A. 큰 동전부터 먼저 쓴다

이게 성립하는 이유는?

500, 100, 50, 10원짜리 동전들을 이렇게 정렬해 놓고 보면, 반드시 큰 쪽은 작은 쪽 액수의 배수

큰 금액의 동전을 자신의 약수인 더 작은 여러 개의 동전들로 교체하면 동전 개수가 반드시 늘어나지만,
작은 동전들이 많이 있다면 이걸 모아 큰 동전 액수를 만들 수 있다면 무조건 바꾸는 게 동전 개수를 줄일 수 있기에 이득

"배수"가 성립하지 않으면 성질이 동일하게 보존되지 않으므로 그리디를 사용할 수 없다



Q. 조리시간이 다른 도시락들을 데우는데 걸리는 시간을 최소화
A. 조리시간이 큰 것부터 데운다

이게 성립하는 이유는?

각 도시락을 데우는 시간은 정해져 있으므로 우리는 도시락을 데우는 시간을 줄이는 건 불가능

그러나 만약 마지막으로 데운 도시락을 먹는 데 오랜 시간이 걸린다면 전체 시간도 길어지는 것이 자명하죠. 따라서 먹는 데 오래 걸리는 것을 먼저 데우고 먼저 먹기 시작하게 하는 겁니다.


그리디 알고리즘(현재 조건에서 가장 최선의 경우를 할당)


## 4796번: 캠핑
> 무조건 가능한 날에는 캠핑을 하면 된다

* step1
	- `answer = V//P*L + min(V%P, L)`

## 1449번: 수리공 항승
> 테이프를 썼다면, 가능한 모든 물 세는 곳을 막는다

* step1
	- 한번에 길이가 L-1인 구간을 모두 덮을 수 있다
	- 정렬 후 제일 왼쪽부터 차례대로 덮을 수 있는 만큼 덮으면 된다

## 17509번: And the Winner is... Ourselves!

언제 문제를 풀던 페널티는 똑같다

* step1
	- 빨리 풀 수 있는 문제부터 풀어서 시간 페널티를 줄이는게 좋다
	- 오래 걸리는 문제를 먼저 풀면 시간 페널티가 커진 상태에서 더 많은 문제를 풀어야 한다





## 1931번: 회의실배정
> 가능한 회의를 최대로 만드는 문제

하지 않아도 되는 회의들이 있다. 그 수를 최소화하는 문제

회의실이 1개, 회의가 여러개일때...

현재 조건에서 항상 최선의 선택을 한다고 보면, 지금부터 끝나는 시간이 가장 빠른 회의부터 처리해나가면 된다

회의실을 끝나는 시간이 빠른 순으로 정렬하고 차례대로 선택 유무를 결정하면 된다
끝나는 시간이 동일한 경우에는?

보통은 끝나는 시간이 같으면 둘 모두를 고를 수 없다. 겹친다
하지만 시작시간=끝나는시간 같은 회의가 가능한 문제이기 때문에
끝나는 시간이 같으면 시작시간이 빠른 것을 먼저 보고 결정해야 한다. 시작시간이 늦은 회의를 먼저 보게되면 시작시간이 빠른 회의를 선택할 수 없게 된다

* step1
	- 끝나는 시간이 빠른, 시작시간이 빠른 순서대로 정렬 후 for-loop



## 11000번: 강의실 배정
> 가능한 회의실 수를 최소로 만드는 문제

모든 회의를 진행해야 한다. 이때 회의실 수를 최소화하는 문제

모든 회의를 해야한다..
현재 조건에서 가장 최선의 선택을 한다고 보면, 시작이 빠른 순서대로 봐야한다


* step1
	- 시작이 빠른 순서대로 탐색. 현재 강의실에 담지 못한다면 강의실을 하나 추가
	- 강의실의 개수가 동적으로 늘어난다 (list)
	- 강의실의 최대 개수는 N개 이므로 O(N^2)
* step2
	- 강의실이 종료시간 기준으로 정렬된 상태라면? 모든 강의실을 볼 필요는 없다
	- 가장 종료시간이 빠른 강의실을 보고, 해당 강의실에서 강의를 시작할 수 있다면 넣고, 아니라면 가능한 강의실이 이미 없다는 뜻이다. 강의실을 하나 추가한다
	- 이때 priority queue를 쓰면 logN 에 강의실을 push, pop 할 수 있다. O(NlogN)

> 유용한 코딩 포인트
그냥 input() 함수를 쓰는 것보다 input=sys.stdin.readline 새로 정의해서 쓰는 것이 빠르다
heappop -> heappush 보다는 heapreplace 도 가능하다


## 1700번: 멀티탭 스케쥴링
> 멀티탭을 뽑는 횟수를 최소화하면서 모든 기기를 사용해나가는 문제

- 현재 취할 수 있는 행동을 구분한다
	- 빈 곳에 꼽는다
	- 이미 꽂혀있다
	- 뽑아야 한다

뽑아야할때 무엇을 뽑느냐의 문제이다

* step1
	- 앞으로 쓰지 않아도 되는 곳을 뽑거나, 가장 나중에 사용하게될 것을 뽑는다
	

## 2212번: 센서
> 모든 센서를 커버하면서 커버 길이를 최소화하는 기지국의 위치를 탐색하는 문제

발상을 전환해야 한다
결국 중요한것은 "커버 길이"를 최소화해야 한다.

"커버 길이"라는 기지국의 위치로 결정이 된다

이때 문제를 기지국의 위치를 결정하는 문제가 아니라 "각 센서간의 길이"를 선택하는 문제라고 생각해보자

기지국은 무조건 많이 쓰면 좋다
기지국이란 이 "각 센서간의 길이" 중 무언가를 선택하지 않아도 되는 기회이다

무엇을 선택하지 않아야 할까? 가장 긴 길이

* step1
	- 기지국은 무조건 많이 쓰면 좋다
	- "각 센서간의 길이" 중 가장 긴 것 K개를 제외한 나머지 길이의 합

## 13904번: 과제
> 마감일과 점수가 정해진 상황에서 점수를 최대화하는 문제

하루에 과제를 한개만 할 수 있다
각 날짜에 어떤 과제를 해나가는게 점수를 극대화할 수 있는지 탐색하는 문제

"문제를 거꾸로 보는 법"

날짜를 처음부터 세는게 아니라, 마지막날부터 센다
마지막날부터 시작해서 할 수 있는 가장 높은 점수의 과제를 해나가면 된다

* step1
	- 마지막날부터 시작해서 할 수 있는 가장 높은 점수의 과제를 해나가면 된다



## 15748번: Rest Stops
> 어디서 휴식을 취하는게 점수를 최대화하는지 탐색하는 문제

이것도 역시 "문제를 거꾸로 보는 법"

지금 쉴 수 있어도, 뒤쪽에 더 높은 점수를 주는 쉼터가 있다면 현재 쉼터는 무조건 건너뛰는게 이득

* step1
	- 점수가 가장 높은 쉼터부터 탐색해나간다
	- 현재 쉼터에서 쉬어버려서 다른 쉼터에서 점수를 얻지 못해도 상관없다



## 1493: 박스 채우기
> 3차원 동전 채우기

박스들의 가로,세로,높이는 모두 2의 거듭제곱 수이므로 서로 배수 관계이다. 서로 호환이 가능하다

동전 채우기의 3차원 버전인데, 가장 큰 것부터 박스를 사용하는 것은 자명해보인다.
하지만 채우고 남은 부분을 어떻게 할 것인가?

첫번째로...
박스를 큰 것부터 사용하는 것은 맞다. 어떤 박스를 어떤 순서로 사용하냐의 문제가 아니라
가장 큰 박스로 현재 공간을 채웠을때, 다음 공간을 어떻게 채우냐의 문제다

공간을 하나로만 생각하면 어렵다
박스를 하나 선택해서 채우게되면, 나머지 공간은 3개의 공간이 생긴다
나머지 3개의 공간에 대해서도 똑같이 큰 박스부터 채워나가는 식으로 탐색하면 된다

그리디 + 분할정복

그런데...
python에서는 이방법으로는 타임아웃이다

내가 처음에 생각했던 방법은 부피 기준으로 큰 것부터 쓸 수 있는 만큼 써가면 되지 않을까? 였는데
이 방법은 틀렸었다

왜냐하면...한쪽으로 긴 박스를 채워야할때 큰 정사각형 블록은 들어가지 않을수도 있다.
이 방법의 맹점은 "부피 기준"으로 생각을 해버려서 들어갈 수 없는 블록도 부피 기준으로는 들어가버린다는 것이다

이걸 피하려면 길이,너비,높이를 항상 고려해다 한다.

두번째 방법은
가장 큰 박스를 먼저 쓴다 (들어가는 개수를 카운팅해본다)
그 다음, 두번째로 큰 박스를 채울때는, 먼저 더 큰 박스로 카운팅 된 부분은 제외하고 채운다

먼저 사용된 박스는 지금 사용하는 박스와 부피가 8배 차이가 나므로, 지금 사용하는 박스로 채웠을때 사용되는 개수에서 8배한 값을 빼준다
(동전으로 치면 가지고 있는 거스름돈을 더 큰 화폐 단위로 바꾸는 것이다. 개수를 최소화하기 위해서)

이런식으로 가장 작은 박스까지 탐색을 하게되면 가장 적은 개수만을 사용해서 부피를 채울 수 있다
혹은 최종적으로 채운 부피가 목표 부피와 다르다면 -1을 출력한다

* step1
	- 그리디 + 분할정복
	- 박스를 채웠을때 다음으로 탐색할 공간은 3차원적으로 3개의 공간이 생긴다
* step2
	- 그리디
	- 작은 화폐단위, 동전을 큰 화폐단위 지폐로 바꾸는 것 처럼, 각각의 박스를 썼을때 채울 수 있는 최대 개수를 구하고, 그 개수에서 더 큰 박스로 채울 수 있는 공간은 얼마나 있는지, 더 큰 박스로 채울 수 있다면 더 큰 박스로 치환한다
	- 탐색은 큰 박스부터 해서, 더 작은 박스를 계산할때 이미 더 큰 박스로 채워진 부분을 알 수 있게 한다


> 유용한 코딩 포인트
input.sort(key = lambda x: x[1], reverse = True)































