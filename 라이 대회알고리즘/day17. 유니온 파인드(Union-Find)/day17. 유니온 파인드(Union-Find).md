# day17. 유니온 파인드(Union-Find)


union-find, disjoint-set 자료구조



union 연산과 find 연산. 2개 연산을 지원

disjoint 집합이란
어떤 두 집합 사이에도 교집합의 원소가 하나도 없고, 모든 집합의 합집합은 전체집합이라는 것

두 원소가 같은 집합에 속해 있는지 확인하는 방법은 각각의 루트를 찾아서 둘이 같은지 비교하는 것입니다.
그러기 위해서 존재하는 연산이 find 연산으로, 어떤 정점의 루트를 찾아줍니다. 자신이 루트라면 바로 자신을 리턴하면 됩니다.

배열 초기화가 필요

크기가 N인 유니온 파인드 구조에 M번 find 연산을 수행했을 때 최악의 시간복잡도는 아까 봤듯이 O(MN)입니다. 정말 지지리도 운이 없어서 N개 원소가 다 일렬로 늘어서있을 때지만, 그래도 가능성이 0은 아니죠.


따라서 유니온 파인드 구조의 시간복잡도를 크기 N, 연산 수 M이라 할 때 합쳐서 O(Mlog * N)으로 취급할 수 있고, O(M)이라 봐도 무방한 수준이겠죠.

> union-by rank, path compression 이 모두 적용되었을때 애커만(N). 거의 상수시간


* 각 도시들이 연결되어있는지, 이동가능한지 (같은 집합에 속하는지)
* 루트 선정시 가중치에 따라서 선정
* 집합의 크기
* BFS + union-find
* union-find + 간선에 cost가 존재
	- 간선 정렬
* 각 집합에 capacity 존재함
* 두 집합을 점차 연결해가는 문제
	- 각 집합을 연결해야 하는데, 각 집합에 남은 여유 용량이 있는지를 확인하는 결정 문제
	- 서랍A, B
	- 공항 gate (i, i-1)
* 그리디 + union-find
	- cost가 낮은 것부터 탐색하면서 양쪽을 연결
	- 뒤쪽 gate부터 도킹가능한지 보면서 앞쪽 1개와 연결
	- 연결을 끊는 문제 -> 끊어진 것을 연결하는 문제로 전환. 역순으로 탐색
* 메타 정보를 남겨야 하는 문제
	- capacity
	- 최소값
	- 최대값
	- 집합의 크기
	- 연결 거리
* 변형 union-find


DSU를 쓰는 곳이
최소값, 최대값, 용량 같은 값을 찾을때 for-loop로 순회하는 것은 너무 오래걸리기 때문에
union-find로 집합을 만들어가면서, 그 집합에서 최소값, 최대값, 용량 같은 것을 한번에 확인하면서 갈 수가 있다.

DSU 역시 쓰이는 곳이 굉장히 많다.
그 집합 내부에서의 순서가 상관없다면 최소값, 최대값, 용량, 집합의 크기 등 다양한 정보를 저장할 수 있다.


* union-find를 while문으로 비재귀로 구현하면 좀 더 빠름




## 1976번: 여행 가자

union-find를 모를때는...플로이드와샬 알고리즘이나 DFS, 다익스트라 ? 이런거로 풀어야하나? 하는 생각이 든다

union-find는 매우 다양하게 쓰이는 자료구조인데, 특히 두 집합의 루트가 같으냐, 같은 집합이냐를 빠르게 판단할때 사용할 수 있다

여기서도 모든 도시들이 같은 집합이냐, 같은 컴포넌트이냐를 판단하는게 필요하기 때문에 union-find가 적절하다


## 16562번: 친구비

모든 노드들이 같은 집합에 속해야한다
이미 같은 집합인 노드들이 있다

각 노드들을 선택할 수 있는 비용이 다르고, 그 비용의 최소를 구한다
완전탐색 + 가지치기?
DP ?

근데 생각해보면, 모든 노드와 같은 집합이 되어야한다. 결국에는
그러면..컴포넌트 수 만큼만 연결을 하면되고, 그중에서 가장 비용이 작은 노드와만 연결을 하면된다
greedy

merge 연산에서 a, b 중에서 cost가 작은것을 루트로 정하고,
두 집합이 같은 컴포넌트가 아닐때 루트를 보고 cost를 결정하면 된다



탐색은 BFS
visit 배열에 문명의 idx를 넣어둔다

자신과 다른 문명의 idx를 만나면 둘을 merge한다

매 step이 진행되기전에 모든 문명(K 100,000)의 루트가 같은지 확인해본다



## 14868번: 문명

이동하지 않아도 인접하기만 해도 서로 결합이 된다

따라서 한번의 BFS로 해결하지 말고, 인접한것들을 머지 후 탐색을 진행해야 한다

문명의 시작지점을 union_q 에 넣고
union_q 에서 머지를 수행하고, bfs_q 로 옮긴다
bfs_q 에서는 이동을 수행하고 union_q 로 옮긴다

....근데 python 에서는 이렇게 하면 시간초과가 나는 것 같다

너무 어렵게 생각한것 같은데, 단순히 구현 문제로 생각해보자

한칸을 이동할때, 이미 방문한적이 있고, root가 다르면 머지한다.
한칸을 이동한뒤, 다시 상하좌우를 탐색해서 root가 다른 문명이 있다면 머지한다.
각각의 경우에 모든 문명이 머지되었다면 종료한다

이렇게 하면 2번에 나눠서 큐를 돌릴 필요가 없다


일단 이문제를 python3로 제출해서 AC 받은 사람이 없다.
최소한 pypy3
나는 pypy3에서 메모리 오류가 발생해서 결국 kotlin으로 해결했다.
앞으로 무거운 알고리즘을 계속 배울 텐데 python으로는 아무래도 한계가 있을듯...



## 3197번: 백조의 호수


물가는 점점 확장하고, 다른 물가끼리 합쳐질 수 있다
합쳐진 물가에 두 마리의 백조가 함께 있다면 둘은 만날 수 있다

따라서 각 물가 영역에 ID를 부여하고 (BFS)
BFS 할때 백조가 있다면 해당 물가에 포함시킨다

백조도 물가 영역으로 취급하고 넣고, 사방이 막힌 백조라면 처음부터 넣어준다

한번 ID를 부여하고, 백조를 포함시키는 BFS, union-find 작업을 완료하고

두번째로 다시 모든 '.'을 queue에 넣고, BFS, union-find 작업을 수행한다.
이때는 얼음을 만나면 녹인다. 그리고 인접해있다면 둘을 union 한다

문명 문제에서 전처리해야할 (어떻게 보면 문명자체가 범위가 된) 것이 추가된 문제


근데 꼭 union-find가 아니라 여러번의 BFS로도 해결 가능한 것 같다
그리고 백조가 있는 곳도 물의 영역이라고 봐야한다

* step1
	- 복합 BFS
* step2
	- 영역 전처리 BFS + BFS + union-find



## 11085번: 군사 이동

어떻게 해결해야 할지 잘 감이 안왔는데, union-find 문제에서는 이런 유형이 흔한가보다

서랍 a,b
비행기,공항
노드1,노드2

이런것들을 연결하는 간선들이 주어질때, 양쪽 진영이 같은 집합에 속할때 답을 출력하는 문제들이다.
그 간선 양쪽의 노드들을 union 해나가면서 푸는 방식의 문제들이다

이문제는 간선들을 선택하는 기준이 가중치로 정렬한뒤 차례차례 union 하는 문제다




## 9938번: 방 청소

술을 서랍에 넣을때, 이동가능한 술들이 연쇄적으로 서랍을 이동할 수 있다.
어떤 식으로, 어디에 들어가는지는 중요하지 않다.
즉 집합의 크기만 허용된다면 술은 그안에서 자유롭게 어떻게든 구겨넣을수 있다.

서랍A i, 서랍B j. i-j 서랍을 계속 묶는다.
이때 집합의 크기를 -1 ~ -N 으로 둬도 되고 별도의 capacity 배열을 둬도 된다.




## 10775번: 공항

일단 기본적으로 비행기를 배치하는게 끝 게이트에 도킹하는게 유리하다는 것을 알아야한다.
그래서 마지막 게이트부터 도킹이 가능한지를 봐야한다

문제에 나타나있지는 않지만, 1~Gi 까지는 모두 도킹이 가능하다는 말은...i번째 게이트에 도킹하려고할때 i-1번째 게이트와만 union을 해주면 된다는 말이다. 이게 되려면 점차 인덱스가 작아지는 방향으로 parent를 설정해야한다

parent가 기본적으로 한칸 앞의 게이트이기때문에, 계속 동일한 lastGate가 들어와도 union을 하면 그것보다 더 한칸 이전 게이트와 union 되기 때문에 점점 앞쪽의 칸을 사용하게 된다. 자연스럽게

그러다가 parent가 0번이 되면 더이상 도킹시킬 자리가 없다는 뜻이다.


이런 작업을 DSU가 아니면, 마지막에서 첫칸까지 for-loop 순회를 돌아야할텐데, 이렇게 하면 시간초과다


* step1
	- 그리디 + for-loop
* step2	
	- 그리디 + DSU


## 15459번: Haybale Feast


굉장히 여러가지 풀이가 있는 것 같다

내가 생각했던 것은 슬라이딩 윈도우로 맛의 합을 보고, 맛의 합이 답이 될때 구간의 최대 매운맛을 max segement tree로 알 수 있지 않을까...생각했다

이분탐색으로도 푼다는데 답이 선형적이지 않은것 같은데 어떻게 가능한지 잘 모르겠다
> https://velog.io/@eldpswp99/%EB%B0%B1%EC%A4%80-15459-Haybale-Feast

* 슬라이딩 윈도우 + segment tree

블로그에서 제시하는 해답은 가장 작은 매운맛부터 시작해서, 양쪽에 자신보다 낮은 매운맛이 있다면 union 해나가는 식으로 진행하는 것이다.
진행하다가 맛이 M 이상이 되는 집합을 만나면 답 출력




DSU를 쓰는 곳이
최소값, 최대값, 용량 같은 값을 찾을때 for-loop로 순회하는 것은 너무 오래걸리기 때문에
union-find로 집합을 만들어가면서, 그 집합에서 최소값, 최대값, 용량 같은 것을 한번에 확인하면서 갈 수가 있다.


이 문제는 매운맛을 작은 순서로 정렬하고, 그 양옆에 자신보다 낮은 매운맛이 있다면, 정답에 영향을 주지 않기 때문에 union 한다.
작은 순서대로 탐색을 진행했을때 맛의 합이 M 이상이 되면 탐색을 종료하고 그 당시의 매운맛 최대값을 출력한다

* step1
	- 그리디 + DSU



## 17398번: 통신망 분할

역으로 연결하는 식으로 cost를 계산해야한다

다 끊어둔 상태에서, 마지막 끊기는 선부터 연결하고, cost 계산하고 이런 식으로

끊어진 것을 연결하는 것도 역순으로 진행해야 한다

* step1
	- 반대로 생각 + DSU
	- 연결을 끊는 문제 -> 끊어진 것을 연결하는 문제로 전환


## 3780번: Corporative Network

disjoinset 인데 이 문제는 '연결거리'를 남기고 업데이트해야 하는 문제다

'연결거리'를 업데이트 하기 위해서는 find 연산에서 재귀적으로 자기 부모와 자기의 거리를 더해주면서 업데이트한다.
이때 거리 업데이트 후 자신을 부모 바로 밑에 붙여야 한다.
그래야 업데이트가 누적되지 않는다. 부모의 연결거리는 0이라서 매번 더해도 업데이트 되지 않는다.

이 문제에서 잘 이해해야하는것은 
두 그룹사이의 root 끼리 union을 하는게 아니라 입력으로 들어온 노드들끼리 그냥 union 하는 것이다
그리고 그냥 A의 root를 B로 바꿔주면 된다




















