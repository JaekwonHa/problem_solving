# day9. 깊이 우선 탐색(Depth-First Search)


* 그래프
* 무방향 그래프
* 방향 그래프
* 가중치 그래프
* 멀티 그래프


* 전체 방문. 깊이 확인
	- dfs, 재귀호출, stack
* 컴포넌트 개수
* 컴포넌트에 포함되는 노드 개수
* 사이클 확인
	- visit, finish
	- 플로이드
* 사이클 개수
* 사이클에 포함되는 노드 개수


## 시간 복잡도

간선의 구현 방법: 인접행렬 / 인접리스트

인접행렬: O(V^2)

인접리스트: O(V+E)
왜냐..

dfs(v)를 한번할때마다. 인접행렬은 V번을 간선이 있는지 없는지 확인하고 탐색해야한다
인접리스트는 각 정점마다 간선의 개수가 다르다
그러면...for문을 V번 돌아야되는데 이때마다 간선의 개수가 e1, e2, e3 개라고 한다면
(v1+e1) + (v2+e2) + (v3+e3) ... = (V+E)
만큼의 탐색이 필요하다

인접행렬은 정점 방문마다 다시 V번을 간선이 있는지 없는지 확인해야한다
이걸 반복하다보면 O(V^2)이 된다

4^2 = 16
4 + 4 + 4 + 4 = 16
(4를 제곱한것과, 4를 4번 더한것은 같다)
O(V+V+V+...V만큼 더하기) = O(V^2)


## 개요


먼저 그래프(graph)라는 자료구조에 대해 알아야 합니다.

그래프의 가장 기본적인 정의는 정점(vertex)과 간선(edge)의 집합입니다.

무방향 그래프(undirected graph)와 방향 그래프(directed graph)로 나눌 수 있습니다.

인접한다(adjacent)는 표현이 있는데 이는 정점 A에서 간선 하나를 거쳐서 정점 B로 이동할 수 있을 때 A와 B가 인접하다는 뜻입니다.

방향 그래프는 차수를 양분할 수 있는데 indegree는 들어오는 간선의 수, outdegree는 나가는 간선의 수입니다.

또한 방향 그래프에서 많이 사용되는 개념 중 싸이클(cycle)이라는 것이 있는데, 간선을 따라가다 보니 시작한 정점으로 돌아오는 경로를 말합니다.



가중치 그래프(weighted graph)는 간선들에 가중치가 있습니다.

이는 비용(weight)일 수도 있고, 두 정점 사이의 거리(distance)를 의미하기도 하며, 때로는 한번에 이동 가능한 최대 양인 대역폭(bandwitch)을 의미하기도 합니다.

방향성을 가지면서 가중치 그래프일 수도 있습니다.



멀티그래프(multigraph)는 똑같은 정점 쌍 (A, B) 사이에 간선이 여러 개일 수 있습니다. 중복되는 간선들이 빨간색으로 표시되어 있습니다.

정점의 입장에서 반대쪽 정점이 같은 간선이 여러 개일 수 있다는 소리이고, 이 때문에 자기 자신으로 돌아오는 (A, A) 같은 간선도 존재하며 이는 파란색으로 표시되어 있습니다.


연결 그래프(connected graph)는 그래프의 컴포넌트가 단 하나인 경우입니다. 즉 모든 정점들이 연결되어 있는 경우죠.
아닌 경우도 있다.


DFS의 시간복잡도는? 정답부터 말하자면 O(V+E)
이는 한 번 방문한 정점은 다시 방문하지 않으며, 한 정점에서 다음으로 방문할 노드들을 순회하는 횟수가 그 정점의 차수와 같기 때문입니다.
> 정점당 무조건 1번은 방문하고. 각 정점에서 간선만큼 탐색해본다. 즉 전체 간선의 수만큼을 더 탐색해본다
> 각 정점에서 간선의 수만큼 for-loop를 도니깐 !

만약 인접 리스트가 없고 인접행렬만 있다면(i행 j열이 1이면 정점 i, j가 연결되어 있단 뜻)?
다음에 방문할 정점을 찾을 때 모든 정점을 순회하며 둘이 이어져 있는지를 체크해야 하므로 O(V^2)입니다. 경우에 따라 압도적인 시간 차이가 납니다.

사이클 cycle
사이클을 구하기위해서는 visit + finish 유무를 저장하는게 필요

다음에 방문할 노드가 visit true인데 finish false라면?
방문한적이 있는데 탐색이 끝나지 않았다는 뜻. 사이클의 발견이다


예를 들자면, 4번 정점에서 DFS를 시작했다고 칩시다. 4번 정점이 7번 정점을 부르고, 7번 정점이 6번 정점을 불렀습니다. 이제 6번 정점이 4번 정점을 부르려는데 visited[4]=true고 finished[4]=false입니다.

이때 4->7->6->4가 하나의 싸이클이 됩니다. 이때 마지막으로 방문한 6번 정점에서 싸이클에 속하는 정점을 다 찾아내야 하는데 이건 쉽습니다. 6번의 다음 정점인 4번부터 그 다음 정점을 6번일 때까지 쭉 순회하면서 싸이클에 포함시키면 됩니다.



그 외, 1, 3번 정점 방문이 끝났고 2번 정점 DFS를 시작했다고 합시다. 그런데 2번 정점이 다음에 부르려는 1번 정점의 경우 visited[1]=finished[1]=true입니다. 그럼 2번 정점은 무슨 짓을 해도 싸이클 안에 없습니다.

3번 정점 방문이 다 끝났고 1번 정점 방문을 부를 때도 마찬가지입니다. 1번 정점이 부르는 3번 정점의 경우 visited[3]=finished[3]=true입니다. 1번 정점 또한 싸이클에 속하지 않죠.

이 두 가지 예를 통해서, 다음 정점이 싸이클 안에 있던 없던 간에 finished가 true면 이번 정점은 싸이클 안에 있을 수 없음을 알 수 있습니다.







## 11724번: 연결 요소의 개수


전체 노드를 한번씩 출발점으로 자신에게 연결된 간선을 따라서 dfs로 탐색하고, 한번 탐색한것을 연결 컴포넌트로 개수를 세면된다

방향없는 그래프라는 점을 놓쳤는데, 방향이 없기 때문에 간선을 양쪽에서 연결해줘야한다

7 0

5 2
1 2
3 2

이런 입력이 디버깅에 도움을 줬다

* step1
	- dfs
	

## 1012번: 유기농 배추

2차원 배열에서 상하좌우를 인접한 노드로 보고 탐색

연결 컴포넌트의 개수

* step1
	- dfs

## 1743번: 음식물 피하기

연결 컴포넌트의 크기


## 2667번: 단지번호붙이기

연결 컴포넌트의 개수, 크기

## 2583번: 영역 구하기

문제를 좀 꼬아서 탐색 불가능 지역을 입력을 받음
N이 상당히 작아서 어떻게든 해결가능


## 11403번: 경로 찾기

인접행렬로 풀수도 있고, 인접리스트로 풀면 좀 더 빠르다

모든 정점에서 각 정점으로의 연결 유무를 파악해야하기 때문에

플로이드 알고리즘으로 V^3 에 해결 가능

근데 거리까지는 필요없고, 연결유무만 보면되기 때문에...


정점 V개. 각 정점마다 DFS를 수행해야하기에 O(V)
한번 DFS를 돌때마다 인접행렬이면 O(V^2)
인접 리스트이면 O(V+E)

인접 리스트라면 총 시간 복잡도 O(V*(V+E))



## 2468번: 안전 영역

수면 높이 1~100까지 연결 컴포넌트의 개수 중 최대값을 출력


근데 이런 문제는 DFS, BFS 무엇으로도 풀 수 있지만

유니온 파인드로도 풀 수 있으니 알아두면 좋을 것 같다

* step1
	- DFS or BFS
* step2
	- 유니온 파인드


## 10552번: DOM

문제만 읽어보면 이게 그래프 문제인가? 판단하기 어려울 것 같다.
하지만 그림을 그려보면서 풀어보면 감을 잡을 수 있다

최대 1개의 인접 간선을 가진다 (간선이 여러개가 있어도 가장 어린 사람의 간선만이 유효하다)
사이클을 발견하기만 하면 되서 visit 배열만 있어도 해결 가능


## 9466번: 텀 프로젝트

모든 정점에 대해서 사이클에 포함되는지 유무를 봐야한다

visit, finish 배열을 사용



## 10265번: MT

"A가 안가면 나도 안간다"  -> B를 데려가려면 A를 데려가야한다는뜻. A를 데려간다고 해서 꼭 B를 데려가진 않아도 된다

이말은 사이클에 해당하는 사람들은 어느 한명을 안데려가면 연쇄적으로 불참하므로 사이클은 모두 데려가야한다

즉, 컴포넌트마다 사이클을 이루는 인원을 최소 인원으로, 컴포넌트의 노드 개수를 최대 인원으로 하여 버스에 태울 수 있다.


이 문제는 SCC + Knapsack 문제로 상당히 어려운 편에 속한다

SCC란
강결합 컴포넌트(Strongly Connected Component)는 방향 그래프에서만 정의된다.
그래프에서 두 정점에 대해서 양방향으로 이동 가능한 경로가 모두 있을 때 두 정점은 같은 강결합 컴포넌트(SCC)에 속한다.
즉, 그래프의 사이클에서 같은 사이클 내에 존재하는 정점들은 같은 SCC에 속한다 할 수 있다.


꼭 SCC가 아니더라도 cycle 크기 + 컴포넌트의 크기는 앞서 배운 문제들을 통해 구할 수 있다
근데 knapsack 문제를 해결 못하겠다..

일단 넘김



















































