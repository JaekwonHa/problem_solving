# day23. 투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window)
> https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220795165570&navType=by

* 투 포인터
	- 합이 M이 되는 구간의 경우의수
	- 플로이드의 순환 탐색 알고리즘(Floyd's cycle detection algorithm)
		+ fast, slow pointer
		+ 연결리스트에서 사이클이 존재하는지 판단
		+ 사이클의 시작점 찾기
* 슬라이딩 윈도우
	- 윈도우 크기가 정해져있음
* 압축 DP


투 포인터, 슬라이딩 윈도우는 O(N). 아주 빠르기 때문에 보통 시간 제한이 아주 낮다
압축 DP의 경우 공간 복잡도가 굉장히 작게 때문에 메모리 제한이 아주 낮다


투 포인터, 슬라이딩 윈도우를 사용하려면 수열이 증가해야한다


## 2003번: 수들의 합 2
## 1644번: 소수의 연속합
## 1806번: 부분합

투 포인터로 부분합이 정확히 M이 되거나 M 이상이 되는 경우의 수를 출력

수가 증가하는 방향이기 때문에 M 이상이 되면 앞쪽 포인터를 앞으로 옮겨주면 된다

## 2230번: 수 고르기

위치에 상관없이 아무 수나 고를 수 있기 때문에 수열을 정렬한뒤 양쪽 포인터의 차를 계산하면 된다

## 1484번: 다이어트

어떠한 두 수의 제곱 차가 G가 되는 문제로 본다면 위 문제와 똑같다

## 2038번: 골롱 수열
> https://www.crocus.co.kr/822

골롱 수열이란 문제는 DP로 해결이 가능하다

G(1) = 1
G(n+1) = 1 + G(n + 1 - G(G(n)))

근데 여기선 N이 20억인데 DP 배열을 만들 수 없다
N보다 f(n)이 작기 때문에 f(n)의 value의 개수 만큼만 배열을 유지한다면 DP로 해결가능하다

다만 개수를 가늠하기 어려우니 map을 쓰면 편하다

Map<f(n) , n의 등장 개수>

따라서 모든 n의 등장 개수의 합이. 현재 index가 된다. 이 index가 N과 같거나 넘어가면 그때의 f(n) (맵의 키)를 출력해주면 된다


```java
    if (N == 1L) {
        bw.println("1")
    } else {
        var sum = 1L
        for (i in 2..N) {
            f_k[i] = 1L + f_k[i - f_k[f_k[i-1]!!]!!]!!

            sum += f_k[i]!!
            if (sum >= N) {
                bw.println(i)
                break
            }
        }
    }
```

## 2531번: 회전 초밥

사이에 있는 초밥의 가짓수를 카운트하기 위해서 Map을 사용했다
회전을 처리하기 위해서 초밥 배열에 0~K개만큼을 뒤에 더 붙였다 (K는 N보다 항상 작거나 같다)
쿠폰을 처리하기 위해서 Map에 99999개의 초밥을 넣어두었다

## 2096번: 내려가기

DP(n)(3) = n까지 내려왔을때 각 블럭들의 최대/최소 값

배열을 prev 1개만 유지하면서 해결 가능
이때 최대, 최소 모두 필요하기 때문에 배열이 2배. 결국 2개가 필요하다

## 2293번: 동전 1

DP(n)(k) = 1~n까지의 동전을 사용하여 k원을 만드는 경우의 수

DP(k)
배열을 prev, current 2개를 유지하면서 해결 가능


사실상 knapsack 문제. (아이템 개수에 제한이 없는)


















