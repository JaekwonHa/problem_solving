# day11. 백트래킹(Backtracking)

완전 탐색 문제

"전체를 탐색해야하기 때문에 DFS를 돈다고 하면 visit 배열을 방문하기 전으로 돌려놓는 작업이 필요하다"

가능한 모든 조합을 다 시도해보는 것

* 가지치기 pruning

해당 방향으로의 탐색이 절대로 최적해가 나오지 않는다면 가치지기를 통해 탐색을 중단할 수도 있다

또한 DFS 말고도 어떤 기준을 매겨서 그 중 가장 가치있는(?) 것을 먼저 방문하는
best-first search 등등, 이런 탐색 쪽에 다른 여러 가지 테크닉이 많습니다.

한번의 탐색이 몇가지로 분기될 수 있는지? 각 분기점에서 어떻게 validate를 할건지. 뭔가 score로 결정이 되는거라면 가지치기할만한 부분은 없는지를 결정해야한다



* visit, used. visit 배열 2개 쓰기
* BFS에서 queue 대신 set 사용해서 해당 레벨에서 중복되는 가지 잘라내기
* 지금 탐색을 시작하려는 메서드 내에서의 score가 이미 찾아진 score 보다도 점수가 안좋다면 탐색할 필요없이 바로 return. (가지치기)
	- 가지치기를 하려면 global answer 변수가 필요
* '조합의수'를 더해주는게 아니라 '조합의확률'을 더해주는 문제
	- 경우의수는 서로 더해주지만, 확률은 서로 곱해준다


## 1987번: 알파벳

트릭
* DFS로 깊게 들어가기 전에 visit 배열을 True -> False 풀어주는 작업이 필요하다
> * visit, 알파벳 used. 총 visit 배열 2개를 사용해야 한다

그런데 python으로 풀면 DFS로는 해결 못한다
그러면 BFS로 해결해야하는데...BFS에서 visit 배열을 닫고 풀어주는 작업을 어떻게 하나?

> 여기서 또 트릭이...BFS에서 queue를 사용하는게 아니라, set을 사용해줄 수 있다
> set을 사용해주면 자연스럽게 중복된 (x,y,path) 조합으로는 새로운 가지가 생기지 않는다!!

queue를 사용하는게 아니기 때문에 step을 답으로 사용할 순 없고, 가장 긴 path 길이를 직접 체크해줘야한다

* step1
	- DFS
* step2
	- BFS
* step3
	- BFS + set instead queue


## 9663번: N-Queen

비숍이랑 문제를 햇갈렸다..
퀸이라면 한 row에 한개의 퀸밖에 두지 못한다
한 row에 N만큼의 퀸을 배치해보는식으로 완전 탐색해본다


이래저래 python으로 해결하기가 쉽지 않은 문제
python으로 백트래킹 문제는 해결이 쉽지 않은 것 같다

golang + dfs 방식으로 해결했다



## 2580번: 스도쿠

스도쿠의 규칙과 상관없이 빈칸이 있으면 1~9 모든 숫자를 한번씩 넣어보고 validate한지를 판단한다


> python으로 해결하기가 쉽지 않은데
> 
> 1. 빈칸의 위치를 먼저 list로 만들어두면 좋다
> 
> 2. validate한지를 볼때 이제 넣을 숫자가 해당 영역에 있는지 정도만 보아도 충분하다.
> 굳이 다른 영역이나, 가능한 후보군을 뽑아 비교를 한다거나 할 필요가 없다


## 10597번: 순열장난

한칸을 자를지, 두칸을 자를지 선택하면서 완전 탐색을 진행

이때 중복되는 숫자는 사용할 수 없는데, answer 배열을 유지하면서 temp in answer 로 비교하면 시간초과

> python으로 해결하기가 쉽지 않은데
> used 배열을 사용해서 특정 숫자를 사용했는지 안했는지 O(1)에 확인해야만 python 에서 통과할 수 있다


## 2661번: 좋은수열

완전 탐색 문제라는 것을 알았다면...
결국 dfs, bfs 로 탐색을 해야한다

이때 한번의 탐색이 몇가지로 분기될 수 있는지? 각 분기점에서 어떻게 validate를 할건지. 뭔가 score로 결정이 되는거라면 가지치기할만한 부분은 없는지를 결정해야한다

이 문제에서는 각 자리수에 1,2,3 세가지 숫자를 둘 수 있다.
각 숫자를 두었을때 이미 선택된 숫자들과 나쁜 수열을 이루는지 확인해서 가지치기를 하면 된다


## 17136번: 색종이 붙이기

색종이의 크기가 10/10으로 고정되어 있다

색종이는 큰 것부터 가능한 것을 붙인다

완전 탐색하고 색종이 선택하고 범위에 색칠하고 이런 것들은 어렵지 않은데..

이 문제는 가지치기를 해야하는 문제다

가지치기를 어떻게 해야할지가 고민이였고,
실제로 수행시켰을때 for-loop가 안끝나는 문제가 있었다.

일단 이문제에서는 visit 배열을 쓰기가 까다롭다. 그래서 가지치기가 필요한 것이다
그래서 '1'을 만났을때 반드시 어떤 색종이로든지 덮어야한다. 덮을 수 없다면 탐색을 더 할 필요가 없다.

그래서 '1'을 만났을때 덮을 색종이 5개를 돌아보고 return하면 된다
다음 '1'을 찾으러 갈 필요가 없다

그리고 가지치기는..
global answer가 업데이트된 상황에서 탐색을 시작하기전, 이미 사용한 paper 개수가 global answer보다 많다면 탐색을 시작할 필요가 없다. 바로 return


## 1189번: 컴백홈

가지수를 출력하는 문제인데, 거리가 정확히 K 입니다.

그냥 완전 탐색하면 되기도 하지만,

도착점에 도착하지 않았는데 거리가 K와 같거나 크다면 더 이상 탐색을 할 필요는 없습니다

가지치기를 연습할 수 있는 문제


## 1405번: 미친 로봇

출력이 소수점이다..

하지만 천천히 생각해보자

모든 단순경로의 수를 찾으면 어떨까?

EENE 뭐 이런 경로가 여러개 나오겠지

이 경로의 확률을 얼마일까?

E * E * N * E 아닐까?


결국 우리가 찾아야할 것은 N 크기의 단순경로이다.
근데 이러한 '조합의수'를 더해주는게 아니라 '조합의확률'을 더해주는 것이다

조합의확률이란 아까 말했듯이 경로를 이루는 모든 확률 값의 곱이다

이 모든 확률 값의 곱의 전체 합이 답이 된다

DFS로 탐색을 한다면 해당 경로로의 확장이 1이 나왔다면 (유효한 단순경로였다.) 그 결과에 확률을 곱해준다.

이러한 확률곱들의 전체 합이 해당 탐색 지점에서의 partial answer 이다


## 1339번: 단어 수학

입력으로 받은 알파벳들을 0-9 사이의 숫자로 바꾸었을때 그 합이 최대가 되는 최댓값을 찾는 문제

이걸 완전 탐색으로 풀어보려면
각 알파벳에 0-9까지 모두 지정해보고 그 중 최대값을 출력하면 된다

'최대값'을 찾는 문제이기에 탐색 도중에 절대로 '최대값'보다 커질 수 없다면 가지치기를 할 수도 있다
(빈 칸에 모두 9를 넣어보는 식으로...)

근데 이런 가지치기로는 

10
A
B
C
D
E
F
G
H
I
J

이런 입력을 커버할 수 없다. 모든 한자리 수에 0-9까지 각각 배치해봐야만 알 수 있다.

답은 나오더라도 결국 python으로는 해결할 수 없다


근데 완전 탐색 문제라는것을 버리고 다시 생각해보면..
여러개의 알파벳 문장들이 주어지지만 결국은 그 합이 중요하다.
그 합 역시 알파벳들의 조합으로 나타낼 수 있다

그렇다면 가장 score가 큰 알파벳(자릿수가 큰것)에 9부터 할당하면 그게 최대값이 되지 않을까??

그리디 알고리즘으로 해결이 가능한 것이다


* step1
	- 백트래킹 + 가지치기
* step2
	- 그리디















































