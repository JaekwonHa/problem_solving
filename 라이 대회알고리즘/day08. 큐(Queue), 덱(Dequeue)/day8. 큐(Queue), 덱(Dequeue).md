# day8. 큐(Queue), 덱(Dequeue)


큐는 스택과 반대로 FIFO(First In First Out) 자료구조

큐 역시 스택과 마찬가지로 연결 리스트를 사용하여 구현합니다. 그러하면 삽입/삭제 연산이 O(1)이죠.


python Queue 모듈은 멀티스레딩, 동시성을 고려하는 설계 때문에 deque보다 느리다


queue 문제는 sliding window와 비슷하게 생각해볼 수도 있을듯


* queue 자체를 여러개 쓰는 문제


## 1966번: 프린터 큐

남은 문서 중에서의 가장 큰 우선순위를 따로 저장해두는게 필요


## 3078번: 좋은 친구

"외계인의 기타 연주" 문제 처럼 stack을 여러개 쓰는 문제

그냥 친구들을 이중 반복문으로 순회할 수도 있다. 시간초과이지만..

그러면 특성이 같은 것끼리, 비교 대상이 같은 학생들을 모아서 그것끼리 비교를 하면 어떨까?

queue를 20개 사용한다

여기서도 다 입력을 받고 처음부터 순회하면서, 이후에 쌍이 되는 이름들이 몇개나 있는지를 체크해볼수도 있다
처음에는 이렇게 해결했는데 이후에 쌍이 되는 이름들, K 이하의 랭크 차이를 가지는 이름들을 순회하는데서 시간초과가 발생하였다

그래서 최적화를 해보자면..
지금 i 번째 이름의 쌍을 찾으러 순회를 시작한다면, 이전 i-1 번째 이름과 쌍의 범위가 일부 겹친다
그렇다면 i 번째 이름의 쌍을 찾으러 순회를 할때 이전 i-1 번째 이름이 순회를 마친 곳 부터 순회를 시작할 수 있다
이렇게 j 번째 탐색지점을 저장해 둔다면 동일 지점의 반복 탐색을 줄일 수 있다

이 방법은 accept 되었지만..


또 다르게 생각해본다면, 탐색 방향을 반대로 생각해볼 수도 있다
특정 이름에서 그 다음으로 쌍이 몇개나 존재할까. 가 아니라
특정 이름을 입력받았을때 이전에 쌍이 몇개나 존재할까. 로 생각해볼 수 있다

특정 이름을 입력받았을때 이전에 K 랭크 이상 차이나는 이름들은 모두 pop하고 남은 queue 사이즈를 더해주고 자신을 추가한다

이 방법이 훨씬 간단할 것이다


* step1
	- 전체 탐색. O(N^2)
* step2
	- queue. 뒷쪽으로 탐색
* step3
	- queue. 이전것들을 탐색


다른 풀이를 보니 sliding window로 head, tail 을 유지하면서 문제를 해결하는 방법도 있어 보인다

queue 문제는 sliding window와 비슷하게 생각해볼 수도 있을듯



## 5430번: AC

reverse의 시간복잡도가 O(N)이므로 문제 그대로 구현하면 시간초과

* step1
	- 리스트를 사용하여 direction에 따라서 0 혹은 -1 에서 pop() 하도록 구현
* step2
	- deque를 사용하여 direction에 따라서 pop() 혹은 popleft() 하도록 구현







































