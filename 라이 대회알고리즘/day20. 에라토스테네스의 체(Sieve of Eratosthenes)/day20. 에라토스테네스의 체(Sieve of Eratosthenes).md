# day20. 에라토스테네스의 체(Sieve of Eratosthenes)
> https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220793360258&navType=by

2중 for-loop로 해결한다면 O(N^2)

에라토스테네스의 채 방식은 2중 for-loop 이지만 O(NlogN)

N이 백만정도로 크다면 더 고속의 알고리즘이 필요한데
O(NloglogN) 의 알고리즘도 있긴 하다
http://stackoverflow.com/questions/2582732/time-complexity-of-sieve-of-eratosthenes-algorithm

기본적인 몇가지 변형
* 소수의 목록은 필요없고 소수인지 아닌지만 판별하면 되는 문제
	- 소수의 목록에 빠르게 접근이 필요하다면 소수만 list에 저장해두는게 좋음
	- 소수인지 아닌지 판별하려면 배열로 저장하는게 좋음
* 소인수분해



*long 타입끼리의 합, 곱은 long 범위를 벗어날 수 있기 때문에 항상 주의해야 한다*

> long 타입끼리의 곱으로 인해 long 범위를 벗어난 경우를 확인하는 방법
> 곱해진 두 수 중 하나의 모듈러 연산으로 0이 되지 않으면 overflow가 발생한 것이다


* 소수판별
* 소인수분해
	- 소인수분해시에 소수리스트가 필요
* 에라토스테네스의 체 변형
	- 소수를 거르는게 아니라 특정한 수식에 의한 값들을 제거하고 남은 수들의 개수나 내용을 출력하는 문제



## 4948번: 베르트랑 공준

소수를 미리 구해둔다

## 3896번: 소수 사이 수열

소수를 미리 구해두고, 작은범위, 큰범위에서 최초로 소수가 나오는 지점까지의 거리 합을 출력한다

## 6588번: 골드바흐의 추측

a + b = n 이 된다
반대로 어떠한 소수 a를 먼저 찾았다면 n-a 가 소수인지를 보면 된다

## 9421번: 소수상근수

소수는 미리 구해둘 수 있는데
상근수는 cycle이 존재할 수 있다

visit 배열(Set)을 사용하면 cycle을 확인할 수 있다

## 2904번: 수학은 너무 쉬워

모든 수를 소인수분해하여 List<Map<Int, Int>> 로 구성한다

최대 GCD란 모든 수의 소인수분해 결과에서, 각 소수의 지수 합을 모든 수에 최대한 골고루 분배한 결과이다

골고루 분해할때 그 수에 소수가 부족하다면 채워줘야 하는데, 이게 이동 횟수가 된다

## 1456번: 거의 소수

소수의 제곱이 a,b 범위에 몇개가 있는지 확인하는 문제

b의 최대 범위가 10^14인데. 소수의 제곱이 10^14 까지 인거라서 소수는 10^7까지만 구해두면 된다

소수 리스트를 순회하면서 그 제곱수들이 a, b 사이에 있는지 확인한다

이때! 소수의 제곱수를 구하는 과정에서 long 타입의 범위를 넘어갈 수 있다

*long 타입끼리의 합, 곱은 long 범위를 벗어날 수 있기 때문에 항상 주의해야 한다*

> long 타입끼리의 곱으로 인해 long 범위를 벗어난 경우를 확인하는 방법
> 곱해진 두 수 중 하나의 모듈러 연산으로 0이 되지 않으면 overflow가 발생한 것이다

## 1016번: 제곱 ㄴㄴ 수

에라토스테네스의 체로 소수판별하는것 처럼 정수의 제곱수를 체에서 지워버리는 문제이다

min,max의 값이 10^12인데, min-max 범위가 10^6 이므로 padding 해서 처리하면 된다

단 이때 a-b 범위로 제곱수의 시작을 옮기는것은 계산으로 한번에 와야한다. +step 을 하나하나하면 시간초과

## 4673번: 셀프 넘버

에라토스테네스의 체 변형문제

1~10,000 까지의 수들을 d(n) 변환을 해보고. d(n) 변환된 것을 체에서 거른다

남은 수들은 생성자가 존재하지 않는 수들이다



























