# day3. 분할 정복(Divide and Conquer)


problem을 sub problem으로 나누어 탐색하는 문제

양쪽으로 나눌 수도 있고, 몇개의 구역, 몇개의 케이스에 대해서 나누어 탐색할 수 있다







## 1629번: 곱셈
> 유명한 고속 거듭제곱 문제

거듭제곱의 원리를 이용해 분할정복하는 문제

2^(n+m) = 2^n * 2^m 을 이용한다

지수가 홀수인 경우와 답을 항상 나머지 연산 해야한다는 점을 유의

* step1
	- for-loop O(N)
* step2
	- DFS + 분할 정복 O(logN)
* step3
	- while 고속 거듭제곱 O(logN)
	- 예전에는 굉장히 익숙했던 것 같은데 지금은 DFS 방식이 좀 더 직관적으로 보인다
	- 이 방법에서는 지수가 홀수인 경우에만 ret 값에 a 값을 곱해주는데.....이유를 아직 이해 못했다


## 2104번: 부분배열 고르기
> sum * min 결과가 최대가 되는 부분 배열을 탐색하는 문제

다양한 최적화 방법이 있다
분할 방법을 양쪽을 줄여나간다고도 생각할 수 있지만,
중앙에서 왼쪽, 오른쪽으로 넓혀가면서 탐색한다고 생각해야한다

* step1
	- 2중 for-loop. left, right 를 한칸씩 옮겨보면서 2중 반복문으로 해결
	- sum, min 을 구하는 방법으로 O(N)을 사용하면 O(N^4)
	- sum * min 계산 한번에 O(N^2)
	- 2중 반복문이 O(N^2)
* step2
	- 2중 반복문을 개선. 1~N 까지의 구역을 (1,mid) / (mid+1,N) 구역으로 반으로 나눠서 탐색
	- O(N^2 * logN)
* step3
	- sum, min 계산을 최적화
	- segmentTree를 사용하여 구간합, 구간최소값을 계산할때 logN 으로 해결
	- 구간합의 경우 부분합으로 O(1)으로 해결 가능
	- O(logN * logN * logN) , O(logN * 1 * logN)
* step4
	- recursive 대신 for-loop, while 문으로 해결
	- 왼쪽 구간의 해, 오른쪽 구간의 해, 중간지점을 포함한 구간의 해. 3가지로 나누어서 탐색한다
	- 왼쪽, 오른쪽은 DFS O(logN)
	- 중간지점을 포함한 구간의 해
		+ mid 부터 시작해서, 왼쪽 오른쪽 중 값이 큰 쪽으로 확장해나가면서 탐색한다
		+ sum을 최대화, min을 최소화하는 방향이기 때문에


## 1725번: 히스토그램
> 부분배열 고르기 문제에서 항상 element가 1인 배열인 케이스이다

stack 으로 해결하는 아이디어는 element가 모두 1인 부분 배열이기 때문에 index를 이용해서 연속되는 너비를 계산하는 것이다
이를 위해서는 사각형을 높이가 긴 순서로 stack에 담을 필요가 있다
담아야할 사각형의 높이가 stack top 보다 낮으면 그 둘은 이제 서로 연결해서 사용할 수 없다
pop을 하면서 현재 위치와 stack top (index) 차를 너비로 사용해서 최대 넓이를 구할 수 있다

* step1
	- 완전 탐색 O(N^2)
* step2
	- 왼쪽, 오른쪽, 중간지점을 포함한 답. 세가지를 분할 탐색하면 된다
	- 분할 정복 O(NlogN)
* step3
	- stack O(N)
	- 각 사각형에 대해서 1번만 검사를 하게됨. (사각형 순회를 반복하게 되는 경우가 없음)


## 1780번: 종이의 개수
> 종이의 종류가 같지 않으면 9방향으로 분할하여 탐색하는 문제

분할 정복으로 간단히 해결 가능

* step1
	- 분할 정복


## 1992번: 쿼드 트리
> 4방향으로 분할하여 탐색하는 문제

분할 정복으로 간단히 해결 가능

* step1
	- 분할 정복

## 1074번: Z
> 분할 탐색

찾고자 하는 좌표가 어느 사분면에 있는지를 판단하고 해당 사분면 쪽으로만 탐색을 진행
지나온 사분면들은 간단한 수식으로 계산 가능

0,0, N,N 같은 좌표 처리. 끝점 처리와 half에 걸치는지 안걸치는지를 잘 판단해야함

* step1
	- 분할 정복


## 2339번: 석판 자르기
> 구현이 어려운 분할 탐색

조건과 구현, 엣지 케이스들이 굉장히 까다로운 문제이다

맵을 탐색하다가 불순물을 발견하면 반드시 가로 or 세로로 분할해야한다.
분할된 맵에서 다시 탐색을 한다

생각의 오류
* '경우의 수'를 찾는 문제니깐 분할하는 순서도 중요하지 않을까? 그래서 가로 or 세로 or 나중에 분할. 이런식으로 탐색해야 하지 않나?
	- 나중에 분할을 생각하지 않아도 된다. '경우의 수'를 찾는 문제라서 지금 분할해서 답이 안나오면 0 리턴 해주면된다.
	- '나중에 분할'이란 개념은 현재 맵에서 결국 다른 불순물을 분할해보는 시나리오에서 탐색을 거치게 된다
* 맵을 계속 순회하는것보다 불순물과 보석의 위치 리스트를 가지고, 이걸 기반으로 탐색하는게 좋지 않을까?
	- 이 생각 때문에 많이 헤맸는데..불순물 기준으로 생각하는건 오류가 있다
	- 결국 '경우의 수'는 어느 불순물을 쪼개었는지가 아니라 그냥 쪼개는 방법 그 자체의 수이다
	- 그래서 가로로 쪼갤때 그 라인에 불순물이 여러개가 있는 상황에서
	- 불순물 기준으로 생각하게 되면 여러번 쪼개서 경우의 수 중복이 생긴다
	- 그래서 맵 기준으로 탐색을 해야 한다

* 가장자리를 쪼갤 수 없음 (가로로 쪼갤것이냐, 세로로 쪼갤것이냐에 따라서 봐야할 조건이 다름)
* 보석을 같이 쪼개면 안됨 (가로로 쪼갤것이냐, 세로로 쪼갤것이냐에 따라서 봐야할 조건이 다름)
* 탐색 종료 조건은 맵 안에 불순물과 보석의 개수로 결정이 된다

가로로 쪼갰을때, 왼쪽 부분에서 생긴 경우의 수와 오른쪽 부분에서 생긴 경우의 수가 있을텐데
전체 경우의 수는 "두 경우의 수의 곱"이 된다


* step1
	- 불순물 기준 분할 탐색
	- 실패
* step2
	- 맵 기준 분할 탐색




























