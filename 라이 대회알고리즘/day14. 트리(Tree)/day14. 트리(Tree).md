# day14. 트리(Tree)
> https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220788265724&navType=by

트리란 그래프의 하위 집합

하지만 이런 특징이 있다
① 연결 그래프이다. (컴포넌트가 하나이다.)
② 방향을 무시하였을 때, 싸이클이 존재하지 않는다.
③ 트리의 간선 개수는 반드시 트리의 정점 개수보다 1 작다.


순회 방법

그래프를 순회하는 방법에는 DFS와 BFS가 있었는데, 여기서도 똑같이 할 수 있습니다.
그러나 트리에서는 순회를 몇 가지로 더 세분화시켰습니다.

전위 순회(preorder traversal)
중위 순회(inorder traversal)
후위 순회(postorder traversal)
레벨 순회(level-order traversal) (BFS)


차수 = 자식 노드의 최대 개수
차수가 2가 아니라 3이라면?

삼진트리. ternary tree
차수가 최대 k라면? k진 트리 k-degree tree



* 트리의 높이를 구하는 문제
* DFS, BFS
* 순회 방법을 다르게 하는 문제
* 루트가 1이 아닌 문제
	- 간선을 연결하는 노드 입력에서, 한번 등장하는 노드가 루트
* 트리의 지름. 2번 탐색하는 문제
	- 꼭 루트에서 시작하지는 않아도 된다
* 트리 DP
	- 모든 정점이 적어도 하나의 인접한 정점 중에는 선택되어 있게 해야 하고, 인접한 두 정점을 선택할 수 없게 할 때. 최대 가중치합
* 트리문제가 아닐 것 같은데, 트리 문제로 변환하는 문제
	- "전체가 이어져 있으며, 두 칸 사이엔 유일한 경로가 존재한다고 말합니다" -> 트리 구조
	- 근데 꼭 트리로 변환해야 하는건 아니고, 입력 자체가 트리임이 보장되니깐 그상태에서 사용해도 되긴 하다
	- 2d map의 어떠한 경로가 트리의 형태라던가 하는 문제





## 1991번: 트리 순회

preorder, inorder, postorder 순회를 구현하는 문제
노드 ID가 중복되지 않기 때문에 python에서는 단순 dictionary 로도 구현할 수 있다

* step
	- 딕셔너리를 이용한 순회 구현

## 11725번: 트리의 부모 찾기

처음에는 뭔가 어떻게 풀어야할지 약간 햇갈렸는데,
트리에서 탐색 문제는 기본적으로 DFS, BFS 라고 생각해야한다

이 문제도 탐색인데
루트부터 BFS로 탐색하면서 자식 노드로 이동하기 전에 해당 자식노드의 부모가 current라고 저장해두고 나중에 출력하면 된다

* step1
	- BFS + 탐색 전 부모 노드를 별도 변수로 저장

## 4803번: 트리

트리의 정의가 노드가 N개, 간선이 N-1개, 경로가 유일이다

마지막 테스트 케이스를 그려보았을때 사이클이 생겨서 사이클의 존재 유무로 트리를 구분하려고 했다
하지만 이건 좀 더 어려운 방법같다.

노드가 N개, 간선이 N-1개라는 조건에서는 사이클이 생기지 않는다
사이클을 찾는 것 보다 노드, 간선의 개수를 세는게 더 간단하다

근데 이건 양방향 그래프이다. 간선을 양쪽 노드에 다 연결하기 때문에...
그렇다면 BFS로 순회시에 같은 간선을 2번 만난다. (visit 때문에 탐색을 하진 않겠지만)

따라서 실제 간선의 수는 나누기2를 해줘야한다. 이 수가 노드-1 과 같은지를 확인해야 한다

* step1
	- BFS + 노드, 간선의 개수를 계산
	- 탐색시 같은 간선을 2번씩 만난다는것 고려

## 1068번: 트리

트리 문제는 좀 햇갈리는게 있는것 같다..
이 문제는 리프노드의 개수를 세는 문제인데..

리프 노드의 정의는 "자식 개수가 0개"인 노드이다

이때 K 노드를 지우게 되는데, K 노드로의 탐색을 하지 않을뿐만 아니라 K 노드가 지워졌을때 새로 리프노드가 되는 케이스를 고려해야한다

예외 처리해줘야 할 것들이 꽤 있다
* 만약에 자식 노드가 1개만 있었는데, 자식 노드가 지워지면 부모 노드는 리프 노드가 된다
* 그리고 루트 노드가 지워지면 리프 노드는 0개이다
* 지워지는 노드로의 탐색은 진행하면 안된다

* step1
	- DFS + 리프노드 개수 계산
	- 노드를 지웠을때의 예외처리


## 16437번: 양 구출 작전

* step1
	- BFS + 모든 양들을 시작점으로
	- 시간초과
	- 중간 지점들을 중복으로 거치게 된다
* step2
	- DFS + 루트에서 한번 탐색
	- 자식 노드의 탐색 결과 result (이동하는 양들의 합)를 현재 노드에 반영해야 한다


## 2250번: 트리의 높이와 너비

트리의 x좌표는 level order, 트리의 y좌표는 in order 순회로 계산할 수 있다
각 순회후에 각 노드들의 x,y 좌표를 확정할 수 있다

각 level 에서 가장 왼쪽 노드의 y 좌표와 오른쪽의 y 좌표를 통해 width를 계산할 수 있다

가장 중요한 점은 "루트 노드가 1이 아닐 수 있다"

다른 풀이를 보니 level order 필요없이, in order 1번으로도 해결 가능한 것 같다.

* step1
	- level order, in order 를 통한 탐색 순서를 x,y 좌표로 변환




## 4256번: 트리

구현이 까다로운 문제

전위순회와 후위순회가 결정되면 트리는 반드시 하나로 결정된다

전위 순회 결과에서 가장 왼쪽에 있는 것이 전체 트리의 루트고, 이 루트의 번호를 중위 순회 결과에서 찾아보면 그 왼쪽에 있는 것이 루트의 왼쪽 서브트리, 오른쪽에 있는 것이 루트의 오른쪽 서브트리가 될 것입니다.

이런 식으로 구간을 계속 나눠가며 재귀 호출로 트리의 구조를 알아내야 합니다.

* step1
	- DFS


## 1967번: 트리의 지름

DFS로 left, right 를 구해서 그 길이를 global answer 와 비교해서 크면 업데이트해주는 식으로 구현하면 될 것 같은데 이 방식으론 accept이 안된다

그래프에서 지름을 길이를 구하는 방법은...
root에서 일단 가장 깊은 노드를 구하고, 가장 깊은 노드에서 다시 가장 깊은 노드를 탐색하면 된다

2번 탐색하는 문제

* step1
	- root -> 가장 깊은 노드, 가장 깊은 노드 -> 다시 가장 깊은 노드 탐색. 그 길이, depth를 계산



## 1949번: 우수 마을

가능한 경우

* 부모가 우수 마을이면, 난 무조건 우수마을이 아님
* 부모가 우수 마을이 아니면
	- 내가 우수 마을이거나
	- 자식들 중 하나는 우수마을이여야함
	
"부모가 우수 마을이 아니고, 나도 우수마을이 아니라면, 자식들 중 하나는 우수마을이여야함"

자식은 최대 2개. 따라서
* 왼쪽 자식을 우수마을로 선정
* 오른쪽 자식을 우수마을로 선정
* 양쪽 자식을 우수마을로 선정

current 에서 자식의 마을까지 선정을 해준다..
자식 마을 입장에서는 내가 우수마을인지 아닌지가 이미 결정되어 있어
그러면 부모가 우수마을인지 아닌지를 보면 안된다

내가 우수 마을이면 자식들은 무조건 우수 마을이 아님
내가 우수 마을이 아니면 자식들 중 최소 하나는 우수 마을이여야함

prev가 우수마을일때, current는 우수마을이 아님. 이때 자식들중 하나는 우수마을일수도 있고, 모두 우수마을 아닐수도 있음

prev가 우수마을이 아니고, current 우수마을이 아님. 이때 자식들중 하나는 우수마을이여야함

prev가 우수마을이 아니고, current 우수마을임. 이때 자식들은 모두 우수마을이 아님

근데 이 케이스에서는 자신도 선택안하고, 자식도 선택안되는 케이스를 커버 못한다


음........좀 너무 어렵게 생각했는데....
주민수, 가중치가 무조건 자연수이기 때문에 '우수마을 선정'은 무조건 하는게 좋다.
이 관점에서 보면 자신이 선택안되었을때, 하위 방향으로 선택할수도 있고, 안할수도 있고로 가도
우려하는 선택안함->선택안함->선택안함.의 상황이 오지 않는다

사이에 있는건 무조건 선택하는게 안하는것보다 좋기 때문에, 탐색이 전부 선택안하는 방향으로 가지를 않는다.

그냥 선택안함/선택함. 으로 탐색시켜도 된다


* step1
	- 트리 DP

모든 정점이 적어도 하나의 인접한 정점 중에는 선택되어 있게 해야 하고, 인접한 두 정점을 선택할 수 없게 할 때, 선택한 정점들의 가중치 합을 구하는 문제는 유명합니다.
그래프에서 이런 종류의 문제는 NP이지만, 트리이기 때문에 DP로 풀 수 있습니다.



## 2533번: 사회망 서비스(SNS)

우수 마을처럼 트리 DP 문제

근데 반대로 우수마을끼리 인접하지 못하는게 아니라, 얼리어답터까리는 인접할 수 있다.
오히려 얼리어답터가 아니라면 주변이 모두 얼리어답터여야 한다

신경쓰지 않아도 되는게, '최소 얼리어답터의 수'를 구하는 것이기 때문에
노드 전체를 얼리어답터로 선택하게 되는 탐색을 진행해도 상관이 없다.
그런 식의 탐색은 '최소 얼리어답터의 수'를 만족할 수 없기에 답이 되지 않는다

탐색 시작은 아무 노드에서나 시작해도 된다

각 노드에서 자신이 얼리어답터 인지 아닌지를 몰라도 된다.
자신을 얼리어답터로 할꺼라면 이후 탐색은 얼리어답터 인것과 아닌것의 최소값이다.
자신을 얼리어답터로 안할꺼라면 이후 탐색은 얼리어탑터 인것이다.

* step1
	- DFS + 트리 DP




## 3482번: Labyrinth

문제 조건 중
"The labyrinth is designed in such a way that there is exactly one path between any two free blocks."가 미궁은 전체가 이어져 있으며, 두 칸 사이엔 유일한 경로가 존재한다고 말합니다.

-> 미궁이 트리 구조라는 말입니다. 트리의 지름 문제와 같습니다. 

미궁의 인접한 경로를 트리로 변환해서 트리의 지름을 구하는 문제로 해결 가능


근데 꼭 인접리스트로 변경해서 풀지 않아도 된다.
미궁맵 자체가 트리로 주어지기 때문에 맵에서 인접행렬로 DFS, BFS 해도 된다

python 이라서 BFS로 해결했다.

출력 양식을 다르게 해서 1시간 정도 더 고생했다...

* step1
	- BFS + 트리의 지름






















